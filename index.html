<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenCV.js Camera Capture</title>
    <script src="https://docs.opencv.org/master/opencv.js" type="text/javascript"></script>
    <style>
        #canvasOutput, #videoInput {
            display: block;
            margin: 0 auto;
        }
        #switchCamera, #capture {
            position: absolute;
            top: 20px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: #4CAF50;
            color: white;
            font-size: 24px;
            border: none;
            cursor: pointer;
            margin-right: 10px;
        }
        #switchCamera { right: 100px; }
        #capture { right: 20px; }
        #capturedImage {
            display: block;
            margin: 20px auto;
            border: 2px solid #4CAF50;
            max-width: 100%;
        }
    </style>
</head>
<body>
    <video id="videoInput" width="640" height="480" autoplay></video>
    <canvas id="canvasOutput" width="640" height="480"></canvas>
    <canvas id="canvasCapture" width="640" height="480" style="display:none;"></canvas>
    <button id="switchCamera">&#x21bb;</button>
    <button id="capture">&#x1f4f7;</button>
    <img id="capturedImage" alt="Captured Quadrilateral" style="display:none;">

    <script type="text/javascript">
        // Constants for adjusting detection parameters
        const CANNY_THRESHOLD_1 = 30;        // Lower threshold for Canny edge detection
        const CANNY_THRESHOLD_2 = 100;       // Upper threshold for Canny edge detection
        const APPROX_POLY_TOLERANCE = 0.05;  // Tolerance for contour approximation (cv.approxPolyDP)
        const DILATE_ITERATIONS = 1;         // Number of iterations for dilation
        const ERODE_ITERATIONS = 1;          // Number of iterations for erosion
        const FRAME_RATE = 30;               // Frames per second for processing

        let video = document.getElementById('videoInput');
        let canvasOutput = document.getElementById('canvasOutput');
        let canvasCapture = document.getElementById('canvasCapture');
        let capturedImage = document.getElementById('capturedImage');
        let switchButton = document.getElementById('switchCamera');
        let captureButton = document.getElementById('capture');
        let stream = null;
        let facingMode = "environment";  // Start with back camera (default)
        let cap, src, dst, largestRect;

        // Initialize OpenCV once fully loaded
        cv['onRuntimeInitialized'] = function() {
            startCamera(facingMode);

            // Add event listener to switch camera button
            switchButton.addEventListener('click', function() {
                facingMode = facingMode === "user" ? "environment" : "user"; // Switch between front and back
                stopCamera();
                startCamera(facingMode);
            });

            // Add event listener to capture button
            captureButton.addEventListener('click', function() {
                if (largestRect) {
                    captureLargestQuadrilateral(largestRect);
                }
            });

            function startCamera(facingMode) {
                // Access the camera with the correct facing mode
                navigator.mediaDevices.getUserMedia({
                    video: { facingMode: facingMode }
                }).then(function(cameraStream) {
                    stream = cameraStream;
                    video.srcObject = stream;
                    video.play();
                    cap = new cv.VideoCapture(video); // Initialize video capture from video element
                }).catch(function(err) {
                    console.error('Error accessing camera.');
                });

                // Process the video stream
                video.addEventListener('play', function() {
                    // Initialize src and dst matrices when video starts playing
                    if (!src || !dst) {
                        src = new cv.Mat(video.height, video.width, cv.CV_8UC4);
                        dst = new cv.Mat(video.height, video.width, cv.CV_8UC1);
                    }

                    function processVideo() {
                        // Capture the frame from the video element using VideoCapture
                        cap.read(src);

                        // Convert to grayscale
                        cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY, 0);

                        // Apply Gaussian blur to reduce noise
                        cv.GaussianBlur(dst, dst, new cv.Size(5, 5), 0);

                        // Apply Canny edge detection
                        cv.Canny(dst, dst, CANNY_THRESHOLD_1, CANNY_THRESHOLD_2);  // Using constants

                        // Dilate and Erode to strengthen edges and reduce noise
                        let kernel = cv.Mat.ones(3, 3, cv.CV_8U);
                        cv.dilate(dst, dst, kernel, new cv.Point(-1, -1), DILATE_ITERATIONS);  // Using constant
                        cv.erode(dst, dst, kernel, new cv.Point(-1, -1), ERODE_ITERATIONS);    // Using constant
                        kernel.delete();

                        // Find contours
                        let contours = new cv.MatVector();
                        let hierarchy = new cv.Mat();
                        cv.findContours(dst, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                        // Disable red debugging - Remove this line to enable contour debugging
                        // cv.drawContours(src, contours, -1, contourColor, 2);

                        // Find the largest quadrilateral
                        largestRect = null;
                        let largestArea = 0;
                        
                        for (let i = 0; i < contours.size(); i++) {
                            let cnt = contours.get(i);
                            let perimeter = cv.arcLength(cnt, true);
                            let approx = new cv.Mat();
                            cv.approxPolyDP(cnt, approx, APPROX_POLY_TOLERANCE * perimeter, true);  // Using constant

                            // If the contour has 4 vertices, it's a potential quadrilateral
                            if (approx.rows === 4) {
                                let rect = cv.boundingRect(approx);
                                let area = rect.width * rect.height;

                                // Check if this is the largest quadrilateral found
                                if (area > largestArea) {
                                    largestArea = area;
                                    largestRect = rect;  // Store the largest rectangle
                                }

                                approx.delete();
                            }
                        }

                        // If a largest quadrilateral was found, draw it in green
                        if (largestRect) {
                            let rectColor = new cv.Scalar(0, 255, 0, 255); // Green color for the largest quadrilateral
                            cv.rectangle(src, new cv.Point(largestRect.x, largestRect.y), new cv.Point(largestRect.x + largestRect.width, largestRect.y + largestRect.height), rectColor, 2);
                        }

                        contours.delete();
                        hierarchy.delete();

                        // Display the result on the canvas
                        cv.imshow('canvasOutput', src);

                        // Schedule the next frame processing
                        setTimeout(processVideo, 1000 / FRAME_RATE);  // Using constant
                    }

                    // Start processing the video
                    processVideo();
                });
            }

            // Stop the camera and release the stream
            function stopCamera() {
                if (stream) {
                    let tracks = stream.getTracks();
                    tracks.forEach(track => track.stop());
                    video.srcObject = null;
                }
            }

            // Capture and draw the largest quadrilateral on the capture canvas
            function captureLargestQuadrilateral(rect) {
                // Create a region of interest (ROI) from the largest quadrilateral
                let roi = src.roi(rect);

                // Display the captured image on the hidden canvas
                cv.imshow('canvasCapture', roi);

                // Convert the canvas to an image and display it on the page
                let dataUrl = canvasCapture.toDataURL('image/png');  // Convert the canvas to a data URL
                capturedImage.src = dataUrl;  // Set the data URL as the image source
                capturedImage.style.display = 'block';  // Show the captured image

                roi.delete();  // Clean up
            }
        };
    </script>
</body>
</html>
