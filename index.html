<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenCV.js Playing Card Detection (Live Camera)</title>
    <script async src="https://docs.opencv.org/master/opencv.js" type="text/javascript"></script>
    <style>
        #canvasOutput, #videoInput {
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    <video id="videoInput" width="640" height="480" autoplay></video>
    <canvas id="canvasOutput" width="640" height="480"></canvas>

    <script type="text/javascript">
        let video = document.getElementById('videoInput');
        let canvasOutput = document.getElementById('canvasOutput');
        let src, dst;

        // Access the camera using getUserMedia
        navigator.mediaDevices.getUserMedia({ video: true }).then(function(stream) {
            video.srcObject = stream;
            video.play();
            console.log('Camera stream started.');
        }).catch(function(err) {
            console.error('Error accessing camera: ' + err);
        });

        // Process each frame from the camera
        video.addEventListener('play', function() {
            const FPS = 30; // Frames per second for processing

            function processVideo() {
                // Capture a frame from the video
                if (!src) {
                    src = new cv.Mat(video.height, video.width, cv.CV_8UC4);
                    dst = new cv.Mat(video.height, video.width, cv.CV_8UC1);
                }

                // Read the current frame from the video element
                cv.imread(video, src);

                // Convert to grayscale
                cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY, 0);

                // Apply Gaussian blur to reduce noise
                cv.GaussianBlur(dst, dst, new cv.Size(5, 5), 0);

                // Apply Canny edge detection
                cv.Canny(dst, dst, 50, 150);

                // Dilate and Erode to strengthen edges and reduce noise
                let kernel = cv.Mat.ones(3, 3, cv.CV_8U);
                cv.dilate(dst, dst, kernel, new cv.Point(-1, -1), 1);
                cv.erode(dst, dst, kernel, new cv.Point(-1, -1), 1);
                kernel.delete();

                // Find contours
                let contours = new cv.MatVector();
                let hierarchy = new cv.Mat();
                cv.findContours(dst, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                // Loop through the contours to find quadrilaterals or rectangles
                for (let i = 0; i < contours.size(); i++) {
                    let cnt = contours.get(i);
                    let perimeter = cv.arcLength(cnt, true);
                    let approx = new cv.Mat();
                    cv.approxPolyDP(cnt, approx, 0.04 * perimeter, true);

                    // If the contour has 4 vertices, it's a potential quadrilateral
                    if (approx.rows === 4) {
                        // Extract the bounding rectangle
                        let rect = cv.boundingRect(approx);

                        // Draw a bounding rectangle around the detected quadrilateral
                        let rectColor = new cv.Scalar(0, 255, 0, 255); // Green color
                        cv.rectangle(src, new cv.Point(rect.x, rect.y), new cv.Point(rect.x + rect.width, rect.y + rect.height), rectColor, 2);
                    }

                    approx.delete();
                }

                contours.delete();
                hierarchy.delete();

                // Display the result on the canvas
                cv.imshow('canvasOutput', src);

                // Schedule the next frame processing
                setTimeout(processVideo, 1000 / FPS);
            }

            // Start processing the video
            processVideo();
        });
    </script>
</body>
</html>
