<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenCV.js Playing Card Detection</title>
    <script async src="https://docs.opencv.org/master/opencv.js" type="text/javascript"></script>
</head>
<body>
    <input type="file" id="fileInput">
    <canvas id="canvasOutput"></canvas>

    <script type="text/javascript">
        let src, dst;
        const canvasOutput = document.getElementById('canvasOutput');
        const fileInput = document.getElementById('fileInput');

        fileInput.onchange = function (e) {
            let img = new Image();
            img.onload = function () {
                canvasOutput.width = img.width;
                canvasOutput.height = img.height;
                let ctx = canvasOutput.getContext('2d');
                ctx.drawImage(img, 0, 0, img.width, img.height);

                console.log('Image loaded successfully.');

                // Load the image into OpenCV
                src = cv.imread(canvasOutput);
                dst = new cv.Mat();

                // Convert to grayscale
                cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY, 0);

                // Apply Canny edge detection
                cv.Canny(dst, dst, 50, 150);

                // Find contours
                let contours = new cv.MatVector();
                let hierarchy = new cv.Mat();
                cv.findContours(dst, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                // Loop through the contours to find rectangles (potential cards)
                for (let i = 0; i < contours.size(); i++) {
                    let cnt = contours.get(i);
                    let perimeter = cv.arcLength(cnt, true);
                    let approx = new cv.Mat();
                    cv.approxPolyDP(cnt, approx, 0.02 * perimeter, true);

                    // If we have found a quadrilateral (4 corners)
                    if (approx.rows === 4) {
                        console.log('Quadrilateral detected.');

                        // Extract the points of the quadrilateral
                        let points = [];
                        for (let j = 0; j < 4; j++) {
                            let point = approx.data32S.slice(j * 2, j * 2 + 2);
                            points.push({ x: point[0], y: point[1] });
                        }

                        // Step 1: Sort points (to make the quadrilateral straighter)
                        points = sortCorners(points);

                        // Step 2: Draw the quadrilateral in green
                        let quadColor = new cv.Scalar(0, 255, 0, 255); // Green for quadrilaterals
                        for (let k = 0; k < 4; k++) {
                            let startPoint = new cv.Point(points[k].x, points[k].y);
                            let endPoint = new cv.Point(points[(k+1) % 4].x, points[(k+1) % 4].y);
                            cv.line(src, startPoint, endPoint, quadColor, 2);
                        }

                        // Apply perspective transformation to extract the card
                        let cardWidth = 200, cardHeight = 300;
                        let dstPoints = [
                            new cv.Point(0, 0),
                            new cv.Point(cardWidth - 1, 0),
                            new cv.Point(cardWidth - 1, cardHeight - 1),
                            new cv.Point(0, cardHeight - 1)
                        ];

                        // Apply perspective transformation
                        let srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [].concat(...points.map(p => [p.x, p.y])));
                        let dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [].concat(...dstPoints.map(p => [p.x, p.y])));
                        let M = cv.getPerspectiveTransform(srcTri, dstTri);

                        let warped = new cv.Mat();
                        cv.warpPerspective(src, warped, M, new cv.Size(cardWidth, cardHeight));

                        console.log('Perspective transformation applied.');

                        // Show the final result (card extraction)
                        cv.imshow('canvasOutput', warped);

                        // Clean up
                        srcTri.delete();
                        dstTri.delete();
                        M.delete();
                        warped.delete();
                    }
                    approx.delete();
                }

                contours.delete();
                hierarchy.delete();

                // Show the image with the quadrilateral
                cv.imshow('canvasOutput', src);
            };
            img.src = URL.createObjectURL(e.target.files[0]);
        };

        // Function to sort quadrilateral points into top-left, top-right, bottom-right, bottom-left order
        function sortCorners(points) {
            // Sort by y-coordinate (to split top and bottom points)
            points.sort((a, b) => a.y - b.y);
            let topPoints = points.slice(0, 2);  // The two top points
            let bottomPoints = points.slice(2, 4);  // The two bottom points

            // Sort the top and bottom points by x-coordinate to get left and right
            topPoints.sort((a, b) => a.x - b.x);
            bottomPoints.sort((a, b) => a.x - b.x);

            // Return points in the correct order: top-left, top-right, bottom-right, bottom-left
            return [topPoints[0], topPoints[1], bottomPoints[1], bottomPoints[0]];
        }
    </script>
</body>
</html>
