<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenCV.js Camera Switch with Contour Debugging</title>
    <script src="https://docs.opencv.org/master/opencv.js" type="text/javascript"></script>
    <style>
        #canvasOutput, #videoInput {
            display: block;
            margin: 0 auto;
        }
        #switchCamera {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: #4CAF50;
            color: white;
            font-size: 24px;
            border: none;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <video id="videoInput" width="640" height="480" autoplay></video>
    <canvas id="canvasOutput" width="640" height="480"></canvas>
    <button id="switchCamera">&#x21bb;</button>

    <script type="text/javascript">
        // Constants for adjusting detection parameters
        const CANNY_THRESHOLD_1 = 30;        // Lower threshold for Canny edge detection
        const CANNY_THRESHOLD_2 = 100;       // Upper threshold for Canny edge detection
        const APPROX_POLY_TOLERANCE = 0.05;  // Tolerance for contour approximation (cv.approxPolyDP)
        const DILATE_ITERATIONS = 1;         // Number of iterations for dilation
        const ERODE_ITERATIONS = 1;          // Number of iterations for erosion
        const FRAME_RATE = 30;               // Frames per second for processing

        let video = document.getElementById('videoInput');
        let canvasOutput = document.getElementById('canvasOutput');
        let switchButton = document.getElementById('switchCamera');
        let stream = null;
        let facingMode = "environment";  // Start with back camera (default)
        let src, dst;

        // Initialize OpenCV once fully loaded
        cv['onRuntimeInitialized'] = function() {
            startCamera(facingMode);

            // Add event listener to switch camera button
            switchButton.addEventListener('click', function() {
                facingMode = facingMode === "user" ? "environment" : "user"; // Switch between front and back
                stopCamera();
                startCamera(facingMode);
            });

            function startCamera(facingMode) {
                // Access the camera with the correct facing mode
                navigator.mediaDevices.getUserMedia({
                    video: { facingMode: facingMode }
                }).then(function(cameraStream) {
                    stream = cameraStream;
                    video.srcObject = stream;
                    video.play();
                }).catch(function(err) {
                    console.error('Error accessing camera.');
                });

                // Process the video stream
                video.addEventListener('play', function() {
                    // Initialize src and dst only once when video starts playing
                    if (!src || !dst) {
                        src = new cv.Mat(video.height, video.width, cv.CV_8UC4);
                        dst = new cv.Mat(video.height, video.width, cv.CV_8UC1);
                    }

                    function processVideo() {
                        // Read the current frame from the video element
                        cv.imread(video, src);

                        // Convert to grayscale
                        cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY, 0);

                        // Apply Gaussian blur to reduce noise
                        cv.GaussianBlur(dst, dst, new cv.Size(5, 5), 0);

                        // Apply Canny edge detection
                        cv.Canny(dst, dst, CANNY_THRESHOLD_1, CANNY_THRESHOLD_2);  // Using constants

                        // Dilate and Erode to strengthen edges and reduce noise
                        let kernel = cv.Mat.ones(3, 3, cv.CV_8U);
                        cv.dilate(dst, dst, kernel, new cv.Point(-1, -1), DILATE_ITERATIONS);  // Using constant
                        cv.erode(dst, dst, kernel, new cv.Point(-1, -1), ERODE_ITERATIONS);    // Using constant
                        kernel.delete();

                        // Find contours
                        let contours = new cv.MatVector();
                        let hierarchy = new cv.Mat();
                        cv.findContours(dst, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                        // Draw all contours in red for debugging
                        let contourColor = new cv.Scalar(255, 0, 0, 255); // Red
                        cv.drawContours(src, contours, -1, contourColor, 2);

                        // Loop through the contours to find quadrilaterals or rectangles
                        for (let i = 0; i < contours.size(); i++) {
                            let cnt = contours.get(i);
                            let perimeter = cv.arcLength(cnt, true);
                            let approx = new cv.Mat();
                            cv.approxPolyDP(cnt, approx, APPROX_POLY_TOLERANCE * perimeter, true);  // Using constant

                            // If the contour has 4 vertices, it's a potential quadrilateral
                            if (approx.rows === 4) {
                                console.log('Quadrilateral detected.');

                                // Extract the bounding rectangle
                                let rect = cv.boundingRect(approx);

                                // Draw a bounding rectangle around the detected quadrilateral
                                let rectColor = new cv.Scalar(0, 255, 0, 255); // Green color for valid quadrilaterals
                                cv.rectangle(src, new cv.Point(rect.x, rect.y), new cv.Point(rect.x + rect.width, rect.y + rect.height), rectColor, 2);
                            }

                            approx.delete();
                        }

                        contours.delete();
                        hierarchy.delete();

                        // Display the result on the canvas
                        cv.imshow('canvasOutput', src);

                        // Schedule the next frame processing
                        setTimeout(processVideo, 1000 / FRAME_RATE);  // Using constant
                    }

                    // Start processing the video
                    processVideo();
                });
            }

            // Stop the camera and release the stream
            function stopCamera() {
                if (stream) {
                    let tracks = stream.getTracks();
                    tracks.forEach(track => track.stop());
                    video.srcObject = null;
                }
            }
        };
    </script>
</body>
</html>
