<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenCV.js Playing Card Detection</title>
    <script async src="https://docs.opencv.org/master/opencv.js" type="text/javascript"></script>
</head>
<body>
    <input type="file" id="fileInput">
    <canvas id="canvasOutput"></canvas>

    <script type="text/javascript">
        let src, dst;
        const canvasOutput = document.getElementById('canvasOutput');
        const fileInput = document.getElementById('fileInput');

        fileInput.onchange = function (e) {
            let img = new Image();
            img.onload = function () {
                canvasOutput.width = img.width;
                canvasOutput.height = img.height;
                let ctx = canvasOutput.getContext('2d');
                ctx.drawImage(img, 0, 0, img.width, img.height);

                console.log('Image loaded successfully.');

                // Load the image into OpenCV
                src = cv.imread(canvasOutput);
                dst = new cv.Mat();

                // Convert to grayscale
                cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY, 0);

                // Apply Gaussian blur to reduce noise
                cv.GaussianBlur(dst, dst, new cv.Size(5, 5), 0);

                // Apply Canny edge detection
                cv.Canny(dst, dst, 50, 150);

                // Dilate and Erode to strengthen edges and reduce noise
                let kernel = cv.Mat.ones(3, 3, cv.CV_8U);
                cv.dilate(dst, dst, kernel, new cv.Point(-1, -1), 1);
                cv.erode(dst, dst, kernel, new cv.Point(-1, -1), 1);
                kernel.delete();

                // Find contours
                let contours = new cv.MatVector();
                let hierarchy = new cv.Mat();
                cv.findContours(dst, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                console.log('Contours found:', contours.size());

                // Loop through the contours
                for (let i = 0; i < contours.size(); i++) {
                    let cnt = contours.get(i);
                    let perimeter = cv.arcLength(cnt, true);
                    let approx = new cv.Mat();
                    cv.approxPolyDP(cnt, approx, 0.04 * perimeter, true); // More forgiving approx

                    // If the contour has 4 vertices, it's a potential quadrilateral
                    if (approx.rows === 4) {
                        console.log('Quadrilateral detected.');

                        // Extract the bounding rectangle
                        let rect = cv.boundingRect(approx);

                        // Draw a bounding rectangle around the detected quadrilateral
                        let rectColor = new cv.Scalar(0, 255, 0, 255); // Green color
                        cv.rectangle(src, new cv.Point(rect.x, rect.y), new cv.Point(rect.x + rect.width, rect.y + rect.height), rectColor, 2);

                        // Extract the card using perspective transformation (optional)
                        let cardWidth = 200, cardHeight = 300;
                        let dstPoints = [
                            new cv.Point(0, 0),
                            new cv.Point(cardWidth - 1, 0),
                            new cv.Point(cardWidth - 1, cardHeight - 1),
                            new cv.Point(0, cardHeight - 1)
                        ];

                        let points = [
                            new cv.Point(rect.x, rect.y),
                            new cv.Point(rect.x + rect.width, rect.y),
                            new cv.Point(rect.x + rect.width, rect.y + rect.height),
                            new cv.Point(rect.x, rect.y + rect.height)
                        ];

                        // Apply perspective transformation
                        let srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [].concat(...points.map(p => [p.x, p.y])));
                        let dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [].concat(...dstPoints.map(p => [p.x, p.y])));
                        let M = cv.getPerspectiveTransform(srcTri, dstTri);

                        let warped = new cv.Mat();
                        cv.warpPerspective(src, warped, M, new cv.Size(cardWidth, cardHeight));

                        console.log('Perspective transformation applied.');

                        // Show the extracted card (optional)
                        cv.imshow('canvasOutput', warped);

                        // Clean up
                        srcTri.delete();
                        dstTri.delete();
                        M.delete();
                        warped.delete();
                    }

                    approx.delete();
                }

                contours.delete();
                hierarchy.delete();

                // Show the image with bounding rectangles
                cv.imshow('canvasOutput', src);
            };
            img.src = URL.createObjectURL(e.target.files[0]);
        };
    </script>
</body>
</html>
